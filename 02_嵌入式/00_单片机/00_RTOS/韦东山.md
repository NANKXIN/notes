# 一. FreeRTOS内部机制

## 1. 任务\_ARM架构_汇编

### 1.1 汇编指令

1. 读(4Bytes)：`LDR R0,[addr]  // LDRH 2Bytes LDRB 1Byte`
2. 写：`STR R0,[addr]`
3. 加：`ADD R0,R1,R2          // R0 = R1 + R2`
4. 写内存：`PUSH {R3,LR}      // 将 R3 和 LR 内的值写入内存 `

   > ## 高标号存入高地址
   >
   > | 栈指针操作 | 栈地址 | 数据 |
   > | :-: | :-: | :-: |
   > | step1：写入LR，SP -= 4 | 100 | LR 字节 1 |
   > | | 99 | LR 字节 2 |
   > | | 98 | LR 字节 3 |
   > | | 97 | LR 字节 4 |
   > | step2：写入R3，SP -= 4 | 96 ~ 93 | R3 |
   > | 指令执行完毕：SP -> | 92 | 空 |
   >

5. 读内存：`POP {R3, PC}       // 读内存赋值给 R3 和 PC`

   > ## 高地址读给高标号
   > 
   > | 栈指针操作 | 栈地址 | 数据 |
   > | :-: | :-: | :-: |
   > | 指令执行完毕：SP -> | 100 | LR 字节 1 |
   > | | 99 | LR 字节 2 |
   > | | 98 | LR 字节 3 |
   > | | 97 | LR 字节 4 |
   > | step2：读出LR，SP += 4 | 96 ~ 93 | R3 |
   > | step1：读出R3，SP += 4 | 92 | 空 |
   > 

> #### 小记
>
> 1. 指令在Flash内
>
> 2. ARM寄存器：`R0 ~ R15`，其中`R13 = SP`为栈指针，指向栈顶；`R14 = LR`为链接寄存器，存放跳转地址；`R15 = PC`为程序计数器，存放下一条指令的地址

### 1.2 函数解析

<img src = ".\pic\class01\p2.png" style = "zoom:80%">

<img src = ".\pic\class01\p1.png" style = "zoom:150%">

``````java
// 					void AddTest(int *pa, int *pb) 
0x08001B02 4770      BX       lr
                    // mov pc,lr;
                    // 将pc赋值给lr;
                    // pc -> prvSetupHardware();

//					{ 
// 					volatile int temp; 
0x08001B04 B508      PUSH     {r3,lr}
                    // 分别将 r3, lr 压入栈内;
                    // 当前栈:
                    // lr
                    // r3 = temp的地址
                    // 空 <- sp

// 					temp = *pa; 
0x08001B06 6802      LDR      r2,[r0,#0x00]
                    // 读 pa+0 所指地址到 r2; 
                    // r2 = *pa;
                    // 第1个参数pa存在r0, 即 r0 = pa = &a; 第2个参数pb存在r1, 即 r1 = pb = &b;
0x08001B08 9200      STR      r2,[sp,#0x00]
                    // 将 r2 写入到 sp+0 所指地址;
                    // temp = r2 = *pa;

// 					temp = temp + *pb;
0x08001B0A 680A      LDR      r2,[r1,#0x00]
                    // LDR r2,[pb+0], 即 r2 = *pb;
0x08001B0C 9B00      LDR      r3,[sp,#0x00]
                    // 读 sp+0 所指地址内到 r3;
                    // r3 = temp = *pa;
0x08001B0E 441A      ADD      r2,r2,r3
                    // r2 = r2 + r3 = *pb + temp = *pb + *pa;
0x08001B10 9200      STR      r2,[sp,#0x00]
                    // 将 r2 写入到 sp+0 所指地址;
                    // temp = r2 = *pb + *pa;

// 					*pa = temp; 
0x08001B12 9A00      LDR      r2,[sp,#0x00]
                    // 读 sp+0 所指地址到 r2;
                    // r2 = temp = *pb + *pa;
0x08001B14 6002      STR      r2,[r0,#0x00]
                    // 将 r2 写入到 r0+0 所指地址;
                    // *pa = r2 = temp;

// 					} 
0x08001B16 BD08      POP      {r3,pc}
                    // r3 = temp地址;
                    // pc = lr; 即下一条指令为 prvSetupHardware();
``````



## 2. 栈的作用

# 二. FreeRTOS队列实战

# 三. ARM架构与编程

# 四. 从0写RTOS

