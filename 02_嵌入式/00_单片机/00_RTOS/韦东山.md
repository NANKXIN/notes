# 一. FreeRTOS内部机制

## 1. ARM架构

<img src = ".\pic\class01\p1.png" style = "zoom:100%">

> #### 补充
>
> 1. 程序存在 flash 内，程序即指令
> 2. 数据存在 ram 内，局部变量、寄存器等

## 2. 汇编

### 2.1 汇编指令

1. 读(4Bytes)：`LDR R0,[addr]  // LDRH 2Bytes LDRB 1Byte`
2. 写：`STR R0,[addr]`
3. 加：`ADD R0,R1,R2          // R0 = R1 + R2`
4. 写内存：`PUSH {R3,LR}      // 将 R3 和 LR 内的值写入内存 `

   > ## 高标号存入高地址
   >
   > | 栈指针操作 | 栈地址 | 数据 |
   > | :-: | :-: | :-: |
   > | step1：写入LR，SP -= 4 | 100 | LR 字节 1 |
   > | | 99 | LR 字节 2 |
   > | | 98 | LR 字节 3 |
   > | | 97 | LR 字节 4 |
   > | step2：写入R3，SP -= 4 | 96 ~ 93 | R3 |
   > | 指令执行完毕：SP -> | 92 | 空 |
   >

5. 读内存：`POP {R3, PC}       // 读内存赋值给 R3 和 PC`

   > ## 高地址读给高标号
   > 
   > | 栈指针操作 | 栈地址 | 数据 |
   > | :-: | :-: | :-: |
   > | 指令执行完毕：SP -> | 100 | LR 字节 1 |
   > | | 99 | LR 字节 2 |
   > | | 98 | LR 字节 3 |
   > | | 97 | LR 字节 4 |
   > | step2：读出LR，SP += 4 | 96 ~ 93 | R3 |
   > | step1：读出R3，SP += 4 | 92 | 空 |
   > 

> #### 补充
>
> 1. 指令在Flash内
>
> 2. ARM寄存器：`R0 ~ R15`，其中`R13 = SP`为栈指针，指向栈顶；`R14 = LR`为链接寄存器，存放跳转地址；`R15 = PC`为程序计数器，存放下一条指令的地址

### 2.2 函数解析

<img src = ".\pic\class02\p2.png" style = "zoom:80%">

<img src = ".\pic\class02\p1.png" style = "zoom:150%">

``````java
// 					void AddTest(int *pa, int *pb) 
0x08001B02 4770      BX       lr
                    // mov pc,lr
                    // 将pc赋值给lr;
                    // pc -> prvSetupHardware();

//					{ 
// 					volatile int temp; 
0x08001B04 B508      PUSH     {r3,lr}
                    // 分别将 r3, lr 压入栈内;
                    // 当前栈:
                    // lr
                    // r3 相当于局部变量temp
                    // 空 <- sp

// 					temp = *pa; 
0x08001B06 6802      LDR      r2,[r0,#0x00]
                    // 读 pa+0 所指地址到 r2; 
                    // r2 = *pa;
                    // 第1个参数pa存在r0, 即 r0 = pa = &a, 第2个参数pb存在r1, 即 r1 = pb = &b;
0x08001B08 9200      STR      r2,[sp,#0x00]
                    // 将 r2 写入到 sp+0 所指地址;
                    // 当前栈:
                    // lr
                    // *pa

// 					temp = temp + *pb;
0x08001B0A 680A      LDR      r2,[r1,#0x00]
                    // LDR r2,[pb+0], 即 r2 = *pb;
0x08001B0C 9B00      LDR      r3,[sp,#0x00]
                    // 读 sp+0 所指地址内到 r3;
                    // r3 = *pa;
0x08001B0E 441A      ADD      r2,r2,r3
                    // r2 = r2 + r3 = *pb + *pa;
0x08001B10 9200      STR      r2,[sp,#0x00]
                    // 将 r2 写入到 sp+0 所指地址;
                    // 当前栈:
                    // lr
                    // *pb + *pa
    
// 					*pa = temp; 
0x08001B12 9A00      LDR      r2,[sp,#0x00]
                    // 读 sp+0 所指地址到 r2;
                    // r2 = *pb + *pa;
0x08001B14 6002      STR      r2,[r0,#0x00]
                    // 将 r2 写入到 r0+0 所指地址;
                    // r0 = *pa = r2 = *pb + *pa;

// 					} 
0x08001B16 BD08      POP      {r3,pc}
                    // r3 = *pb + *pa;
                    // pc = lr, 即下一条指令为 prvSetupHardware();
``````

## 3. 任务

### 3.1 现场

> ###### 1. 什么是现场？
>
> 被打断瞬间，**所有**寄存器的值

> ###### 2. 如何保存现场？
>
> 将 R0 ~ R15 存入栈内

> #### 任务
>
> 任务 = 回调函数 + 栈，即运行中的函数

#### 3.2 保存现场的场景

1. 任务切换：保存所有的寄存器

2. 函数切换：用于传参的寄存器无需保存，即R0, R1, R2

   ``````C
   FunA(void)
   {
       FunB(a, b);  // FunA调用FunB时, R0 = a, R1 = b
   }
   ``````

3. 中断切换(Cortex M3/M4)：硬件保存R0, R1, R2；软件保存用到的寄存器

# 二. FreeRTOS队列实战

# 三. ARM架构与编程

# 四. 从0写RTOS

