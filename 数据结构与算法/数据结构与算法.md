# 左程云

## 基础

### 1.认识复杂度、对数器、二分法与异或运算

#### (1).常数时间操作

> 算术运算
> 位运算：>>（带符号）、>>>（不带符号）等
> 赋值、比较、自增、自减等
> 数组寻址

1. 想象该算法流程所处理的数据状况，按照最差情况
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作
3. 如果数据量为N，看看基本动作的数量和N是什么关系

#### (2).简单排序

插入排序
![P1](\pic\P1\插入排序.png)
冒泡排序
![P1](\pic\P1\冒泡排序.png)
选择排序
![P1](\pic\P1\选择排序.png)

#### (3).核心标准

> 1.时间复杂度：流程决定
> 2.额外空间复杂度：流程决定，和功能无关，是自己需要的空间。例：对传入函数的变量进行计算，需要新增变量，为O(1)，若数组，为O(N)
> 3.常数项时间：实现细节决定

额外空间复杂度
![P1](\pic\P1\额外空间复杂度.png)
常数项
![P1](\pic\P1\常数项.png)
最优解
![P1](\pic\P1\最优解.png)

#### (4).对数器

![P1](\pic\P1\对数器.png)

```java
package org.example;

import java.util.Arrays;

public class Main {

    public static void bubbleSort(int[] arr)
    {
        if (arr == null || arr.length < 2)
        {
            return;
        }
        for (int e = arr.length - 1; e > 0; e--)
        {
            for (int i = 0; i < e; i++)
            {
                if (arr[i] > arr[i + 1])
                {
                    swap(arr, i, i + 1);
                }
            }
        }
    }

    public static void swap(int[] arr, int i, int j)
    {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static int[] generateRandomArray(int maxSize, int maxValue)
    {
        // Math.random() [0,1)
        // Math.random() * N [0,N)
        // (int)(Math.random() * N) [0,N-1]
        int[] arr = new int[(int)((maxSize + 1) * Math.random())];

        for (int i = 0; i < arr.length; i++)
        {
            // [-?, +?]
            arr[i] = (int)((maxValue + 1) * Math.random()) - (int)(maxValue * Math.random());
        }

        return arr;
    }

    public static int[] copyArray(int[] arr)
    {
        if (arr == null)
        {
            return null;
        }
        int [] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++)
        {
            res[i] = arr[i];
        }
        return res;
    }

    public static void comparator(int[] arr)
    {
        Arrays.sort(arr);
    }

    public static boolean isEqual(int[] arr1, int[] arr2)
    {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null))
        {
            return false;
        }
        if (arr1 == null && arr2 == null)
        {
            return false;
        }
        if (arr1.length != arr2.length)
        {
            return false;
        }
        for (int i = 0; i < arr1.length; i++)
        {
            if (arr1[i] != arr2[i])
            {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args)
    {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;

        for (int i = 0; i < testTime; i++)
        {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            bubbleSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2))
            {
                succeed = false;
                // 打印 arr1
                // 打印 arr2
                break;
            }
        }

        System.out.println(succeed ? "true" : "false");

    }
}
```

#### (5).二分法

![P1](\pic\P1\二分法.png)

* logN默认以2为底，其它底需要写明

##### (a).查某个值

![P1](\pic\P1\二分查找.png)

```java
// 该计算为有符号
mid = (L + R) / 2;          // 不安全：若L和R超级大，加完溢出
mid = L + ((R - L) >> 1);   // 安全：L + (R - L) / 2，(R - L)为距离

// 常见位运算
// N / 2 == N >> 1
// N * 2 == N << 1
// N + 1 == N | 1
```

##### (b).查最左/右位置

![P1](\pic\P1\二分查找位置.png)

##### (c).局部最小

1.左边最小，0比1小
2.右边最小，N比N-1小
3.i-1 i i+1，i最小

> 例：arr[N], 无序，相邻不等
> 若0比1大，N-2比N-1大，中间必然存在局部最小
> 先找mid位置，判断mid-1和mid+1，同上轮

![P1](\pic\P1\二分局部最小.png)

![P1](\pic\P1\局部最小代码.png)

* <font color=#DC143C>不一定有序才能用二分法，在两种可能性中，只要知道某一种有即可</font>

##### (d).异或运算

异或
![P1](\pic\P1\异或.png)
异或性质
![P1](\pic\P1\异或性质.png)

* <font color=#DC143C>例1：不用额外变量交换两个变量</font>

```C
// 异或运算的性质
// a和b的内存不同，以下成立
a = 甲
b = 乙
a = a ^ b;  // a = 甲 ^ 乙，b = 乙
b = a ^ b;  // a = 甲 ^ 乙，b = 甲 ^ 乙 ^ 乙 = 甲 ^ 0 = 甲
a = a ^ b;  // a = 甲 ^ 乙 ^ 甲 = 乙 ^ 0 = 乙
// 若i = j，以下错误
void swip(int *a, int i, int j)
{
    a[i] = a[i] ^ a[j];
    a[j] = a[i] ^ a[j];
    a[i] = a[i] ^ a[j];
}
```

* <font color=#DC143C>例2：一个数组中有一种数出现了奇数次，其它数都出现了偶数次，怎么找到并打印这种数</font>

### 2. 链表结构、栈、队列、递归行为、哈希表和有序表

### 3. 归并排序和随机快排

### 4. 比较器与堆

### 5. trie、桶排序、排序总结

### 6. 链表相关

### 7. 二叉树的基本算法

### 8. 二叉树的递归套路

### 9. 打表技巧和矩阵处理技巧

### 10. 并查集结构和图相关的算法

### 11. 暴力递归

### 12. 动态规划

### 13. 暴力递归到动态规划1

### 14. 暴力递归到动态规划2

### 15. 暴力递归到动态规划3

### 16. 暴力递归到动态规划4

### 17. 真题

## 实战

### 1. 认识复杂度和简单排序算法

### 2. 认识O(NLogN)的排序

### 3. 详解桶排序以及排序内容大总结

### 4. 详解桶排序以及排序内容大总结
